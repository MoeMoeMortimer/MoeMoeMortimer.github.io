<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>题解文档</title>
</head>
<body>
<h1 align="center">Summer Training Day 4/5/6 题解文档</h1>

<h3>POJ 3255 【次短路】</h3>
<p>次短路是比最短路长度长的次短的路径。我们把路口看作顶点，把道路看作边建立无向图。Dijkstra算法的思路是依次确定尚未确定的顶点中距离最小的顶点。按照这个思路，到某个顶点v的次短路要么是到其他某个顶点u的最短路再加上u->v的边，要么是到u的次短路加上u->v的边，因此要求的就是到所有顶点的最短路和次短路。因此，对于每个顶点，我们记录的不仅仅是最短距离，还有次短距离，用与Dijkstra相同的做法，不断更新这两个距离。
<p>
<br>
<h3>AC代码</h3>
<pre>#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
#define MAXV 5009
#define INF 1<<31-1
using namespace std;
typedef pair<int, int> P;
int R, N;
struct edge{
    int to, cost;
    edge(int u, int d):to(u), cost(d){}
};
vector<edge> G[MAXV];
int d1[MAXV], d2[MAXV];

void dijkstra(){
    priority_queue<P, vector<P>, greater<P>> que;
    fill(d1, d1+N+1, INF);
    fill(d2, d2+N+1, INF);
    d1[1] = 0;
    que.push(P(0, 1));
    while(!que.empty()){
        P p = que.top();
        que.pop();
        int v = p.second, d = p.first;
        if(d2[v] < d)continue;

        for (int i = 0; i < G[v].size(); ++i){
            edge &e = G[v][i];
            int dd = d+e.cost;
            if(d1[e.to] > dd){
                swap(d1[e.to], dd);
                que.push(P(d1[e.to], e.to));
            }
            if(d2[e.to]>dd && d1[e.to]<dd){
                d2[e.to] = dd;
                que.push(P(dd, e.to));
            }
        }
    }
    printf("%d\n", d2[N]);
}

int main(){
    while(cin >> N >> R){
        int u, v, w;
        for(int i = 0; i <= N; i++){
            G[i].clear();
        }
        for (int i = 0; i < R; ++i){
            cin >> u >> v >> w;
            G[u].push_back(edge(v, w));
            G[v].push_back(edge(u, w));
        }
        dijkstra();
    }
    return 0;
}
</pre>

<br>
<br>
<h3> POJ 1182 【带权并查集】
并查集是维护“同一组”的数据结构，那么对每个动物创建三个元素i−A, i−B, i−C。（今早的表达有误，“—”说成减号可能误导大家了，不如说它是一道横杠？i—A指的是一个元素，不是对i进行一次运算）
i−x表示i属于x。
</p>
<br />
建立3×N大小的并查集。


<p>  
并查集同一组的所有元素表示的情况都同时发生。  
由于每个动物所在的种类是不确定的，所以当给出消息判断的时候，需要考虑 i在A,B,C三种情况，那么将三种情况都合并起来即可减少判断量。即
</p>
<br />
情况一
<br /> Union(x, y); // 当x和y都在A组
<br /> Union(x+N, y+N); // 当x和y都在B组
<br /> Union(x+2\*N, y+2\*N); // 当x和y都在C组
<br /> 情况二
<br /> Union(x, y+N); // 表示A的x吃B的y
<br /> Union(x+N, y+2\*N); // 表示B的x吃C的y
<br /> Union(x+2*N, y); // 表示C的x吃A的y
<br>
<h3>AC代码</h3>

<pre>#include <stdio.h>
#include <iostream>

using namespace std;

const int MAX_K = 1000005;
const int MAX_N = 500005;
int N, K;

int T[MAX_K], X[MAX_K], Y[MAX_K];
int parent[3*MAX_N];

void ufSet(int n){

	for (int i = 0; i <= n; ++i){
		parent[i] = -1;
	}
}
int find(int x){
	int s; 
	for (s = x; parent[s] >= 0; s = parent[s]);
	int tmp;
	while(s!=x){
		tmp = parent[x];
		parent[x] = s;
		x = tmp;
	}
	return s;
}


void Union(int R1, int R2){
	int r1 = find(R1), r2 = find(R2);
	int tmp = parent[r1]+parent[r2]; //
	if(r1!=r2){
		if(parent[r1]>parent[r2]){
			parent[r1] = r2;
			parent[r2] = tmp;
		}
		else{
			parent[r2] = r1;
			parent[r1] = tmp;
		}
	}
}

bool same(int x, int y){
	return find(x)==find(y);
}

void solve(){
	//元素x，x+N，x+2*N分别代表x-A, X-B, X-C
	ufSet(N*3);
	int t, x, y;
	int ans = 0;
	for(int i = 0; i < K; i++){
		scanf("%d%d%d", &t, &x, &y);
		x -= 1; y -= 1;
		if(x<0 || N<=x || y<0 || N<=y){
			ans++;
			continue;
		}
		if(t == 1){
			if(same(x, y+N) || same(x, y+2*N)){
				ans++;
			}

			else {
				Union(x, y);
				Union(x+N, y+N);
				Union(x+2*N, y+2*N);
			}
		}

		else {
			if(same(x, y) || same(x, y+2*N)){
				ans++;
			}
			else {
				Union(x, y+N);
				Union(x+N, y+2*N);
				Union(x+2*N, y);
			}
		}
	}

	
	printf("%d\n", ans);
}

int main(int argc, char const *argv[]){
	scanf("%d%d", &N, &K);

	solve();
	return 0;
}
</pre>
<br>
<br>
<h3>ZOJ 1914 【最小生成树】</h3>
<p>任意两基站必须连通，首先要求我们找一棵树。然后由题意，距离不超过D时才能通信，题目要求我们找满足条件的最小的D，也就是最小生成树上最长的边，即下标为p-2的边（编号从0开始）。</p>
</p>但是题目中有附加条件。即可以任意选择s个使用卫星通信基站，这些基站间无论距离多远都可以直接通信。那么我们总能在上述最小生成树中删去s-1条权值最大的边，然后填上s-1条边（权值可看作0）重新构造一颗最小生成树。
</p>
<p>下面证明之。对于一颗含p个结点的树，树上有p-1条边且每条边均为桥（定理），因此删去s-1条边后的图G有s个连通分支，且每个连通分支都是一棵树，在每个连通分支上任选一点（或将连通分支缩成一个点），一定存在一颗用s-1条边将这些点连接起来的树T，使得G⋃T仍为一棵树。</p>
<p>故选择p-s条最小边，在选边时记录每条边的权值，最后输出第p-s条边的权值。
<br>
<h3>AC代码</h3>
<pre>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

typedef struct edge{
    int from,to;
    int dist;
}edge;

edge dis[300000];           //记录from点到to点的距离
int  ans[550];         //记录距离
int coor[510][2];         //记录各个点的坐标
int parent[550];            //定义parent域


int D(int x){
    return(x*x);
}

int P(int i,int j){
    return( D(coor[i][0]-coor[j][0])+D(coor[i][1]-coor[j][1]) );
}

int cmp(const void *a,const void *b){
   return (*(edge *)a).dist - (*(edge *)b).dist;
}


int find(int i){
    if(parent[i] == i)return i;
    parent[i]=find(parent[i]);
    return parent[i];
}
 
int main(){
    int N,s,p,i,j;
    int n = 0;                   
    scanf("%d",&N);
    while(N--){
        scanf("%d%d",&s,&p);
        for(i = 1; i <= p; i++)
          scanf("%d%d",&coor[i][0],&coor[i][1]);       
        n = 0;
        for(i = 1; i < p; i++){
           for(j = i+1; j <= p; j++){
              dis[n].from = i;
              dis[n].to   = j;
              dis[n].dist = P(i,j);
              n++;
            }
        }                
       
        qsort(dis,n,sizeof(edge),cmp);           
       
        for(i = 1; i <= p; i++)parent[i]=i;
        int total = 0;
        for(i = 0; i < n; i++){
             if(find(dis[i].from) != find(dis[i].to)){
                parent[ parent[dis[i].from] ]  =  parent[dis[i].to];
                total++;
                ans[total] = dis[i].dist;
                if(total == (p-s))break;
              }
        }
        printf("%.2lf\n",sqrt(ans[total]));
       
    }
    return 0;
}
</pre>

</body>


</html>